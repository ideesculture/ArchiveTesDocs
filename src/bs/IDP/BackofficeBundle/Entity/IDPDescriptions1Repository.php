<?php

namespace bs\IDP\BackofficeBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Query;

/**
 * IDPDescriptions1Repository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class IDPDescriptions1Repository extends EntityRepository
{
    public function findAll()
    {
        return $this->findBy(array(), array('longname' => 'ASC'));
    }

	public function getAll( )
	{
		$querySelect = "SELECT d FROM bsIDPBackofficeBundle:IDPDescriptions1 d";
		$query = $this->getEntityManager()->createQuery($querySelect);
		return $query->getArrayResult();
	}

    public function getAllIndexedOnID( ){
        $result = [];
        $descriptions = $this->getAll();
        if( !$descriptions ) return null;

        foreach( $descriptions as $description ){
            $result[$description['id']] = $description;
        }
        return $result;
    }

    public function countDescriptions1( $search ){

		$queryStr = 'SELECT COUNT(d.id) ';
		$queryStr .= ' FROM bsIDPBackofficeBundle:IDPDescriptions1 d ';
        if( $search )
            $queryStr .= " WHERE d.longname LIKE '%$search%' ";

		$query = $this->getEntityManager()->createQuery( $queryStr );

		return $query->getSingleScalarResult();
	}

	public function loadDescriptions1Datas( $search, $sort, $order, $limit, $offset ){
		$queryStr = 'SELECT d ';
		$queryStr .= ' FROM bsIDPBackofficeBundle:IDPDescriptions1 d ';
        if( $search )
            $queryStr .= " WHERE d.longname LIKE '%$search%' ";
		$queryStr .= " ORDER BY d.$sort $order ";

		$query = $this->getEntityManager()
			->createQuery( $queryStr )
			->setMaxResults( $limit )
			->setFirstResult( $offset )
			->setHint(Query::HINT_INCLUDE_META_COLUMNS, true);

		return $query->getResult();
	}

	public function findOneWithConstraint( $longname, $service_id ){

	    $query = $this->createQueryBuilder( 'd' )
            ->select( 'd' )
            ->leftJoin( 'd.services', 's' )
            ->addSelect( 's' )
            ->where( 'd.longname = :longname' )
            ->andWhere( 's.id = :sid' )
            ->setParameter( 'longname', $longname )
            ->setParameter( 'sid', $service_id );

        return $query->getQuery()->getResult();
	}

    public function findPrevNext( $description1Id, $sortASC ){
        $em = $this->getEntityManager();

        // On récupère le nom de l'élément courant
        $query = $em->createQuery( "SELECT t.longname FROM bsIDPBackofficeBundle:IDPDescriptions1 t WHERE t.id = :currentid" )
            ->setParameter( 'currentid', $description1Id );
        $currentNameRsp = $query->getResult();
        if( !$currentNameRsp ) return null;
        $currentName = $currentNameRsp[0]['longname'];

        // Get next when ordered ASC
        $query = $em->createQuery( "SELECT MIN(t.longname) as longname FROM bsIDPBackofficeBundle:IDPDescriptions1 t WHERE t.longname > :currentname ORDER by t.longname" )
            ->setParameter( 'currentname' , $currentName )
            ->setMaxResults( 1 );
        $nextEntryRsp = $query->getResult();
        if( !$nextEntryRsp ) $nextEntryName = null;
        else $nextEntryName = $nextEntryRsp[0]['longname'];

        $query = $em->createQuery( "SELECT t.id FROM bsIDPBackofficeBundle:IDPDescriptions1 t WHERE t.longname = :nextname" )
            ->setParameter( 'nextname' , $nextEntryName );
        $nextEntryRsp = $query->getResult();
        if( !$nextEntryRsp ) $nextEntryId = null;
        else $nextEntryId = $nextEntryRsp[0]['id'];

        // Get previous when ordered ASC
        $query = $em->createQuery( "SELECT MAX(t.longname) as longname FROM bsIDPBackofficeBundle:IDPDescriptions1 t WHERE t.longname < :currentname ORDER by t.longname" )
            ->setParameter( 'currentname' , $currentName )
            ->setMaxResults( 1 );
        $previousEntryRsp = $query->getResult();
        if( !$previousEntryRsp ) $previousEntryName = null;
        else $previousEntryName = $previousEntryRsp[0]['longname'];

        $query = $em->createQuery( "SELECT t.id FROM bsIDPBackofficeBundle:IDPDescriptions1 t WHERE t.longname = :previousname" )
            ->setParameter( 'previousname' , $previousEntryName );
        $previousEntryRsp = $query->getResult();
        if( !$previousEntryRsp ) $previousEntryId = null;
        else $previousEntryId = $previousEntryRsp[0]['id'];

        if( $sortASC == 1 )
            return [
                'previous' => [ 'id' => ($previousEntryId===null)?null:$previousEntryId, 'longname'=> ($previousEntryName===null)?null:$previousEntryName ],
                'current' => ['id' => $description1Id, 'longname' => $currentName ],
                'next' => [ 'id' => ($nextEntryId===null)?null:$nextEntryId, 'longname'=> ($nextEntryName===null)?null:$nextEntryName ]
            ];
        else // Order seems to be DESC, so invert
            return [
                'previous' => [ 'id' => ($nextEntryId===null)?null:$nextEntryId, 'longname'=> ($nextEntryName===null)?null:$nextEntryName ],
                'current' => ['id' => $description1Id, 'longname' => $currentName ],
                'next' => [ 'id' => ($previousEntryId===null)?null:$previousEntryId, 'longname'=> ($previousEntryName===null)?null:$previousEntryName ]
            ];

    }
}
